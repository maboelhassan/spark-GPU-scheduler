#include "cuda_kernels.cuh"  /* Include the header (not strictly necessary here) */
#include <stdio.h>
#include <iostream>
#include <sys/time.h>


#define ARGS_NO 3
#define IN_FILE_INDEX 1
#define OUT_FILE_INDEX 2

const int SEG_DATA_LEN = 128;       /*The number of data items in the segment*/
const int HALF_SEG_DATA_LEN = 64;
const double INIT_SEGMENT = 138.553593220;
const double SEGMENT_STEP = 128*5.0/1000000000;
const double pi = 3.141592654;
const double half_pi=pi/2;
const double divPI=360/2/pi;
const double twoPI=2*pi;
const double fifDivPI=15.697*pi/180;
const double az_shift=-75.5666667,Space12=7.18,Space13=6.55;//,Space23=10.95;
const int LowerCutOff=19,UpperCutOff=51;
const double DEV_THRESHOLD = 0.028;
const int threadsPerBlock = 128;   //examples of values used before 625;//1000;
const int numBlocks = 512;

struct segmentProcessor{
    double az_shift,Space12,Space13,Space23;
    int LowerCutOff,UpperCutOff,rc_threshold;
    //int DOUBLE_SEG_DATA_LEN;
    int SEG_DATA_LEN;
    int HALF_SEG_DATA_LEN;
};



/*helping functions*/
__device__ void swap(double data[], int i, int j)
{
    /*double tmp=*a;
    *a=*b;
    *b=tmp;*/
    double t = data[i];
    data[i] = data[j];
    data[j] = t;
}

__device__ double maximum(double b[])
{
	double max = 0.0;
	//int u = 0;
	int e;
	for(e=0;e<SEG_DATA_LEN;e++){
		double t = b[e];
		if(t > max){
			max = t;
			//u = e;
		}
	}
	return (max);
}

__device__ int minim(int sss, double b[])
{
	double min = 1000.0;
	int u = 0;
	int e;
	for(e=0;e<sss;e++){
		double t = fabs(b[e]);
		if(t < min){
			min = t;
			u = e;
		}
	}
	return (u);
}

__device__ double mean(int p,int q,double b[])
{
	double total = 0.0;
	double heikin;
	int e;
	for(e=p;e<q;e++) total = total + b[e];
	heikin = total / (q-p);
	return (heikin);
}

__device__ double s_deviation(int p, int q,double b[])
{
	double total2 = 0.0;
	double hensa,avg;
	avg = mean(p,q,b);
	int e;
	for(e=p;e<q;e++) total2 = total2 + (b[e]-avg)*(b[e]-avg);
	hensa = sqrt(total2/(q-p));
	return (hensa);
}



__device__ void four1(double data[], unsigned long nn, int isign)
{
	unsigned long n,mmax,m,j,istep,i;
	double wtemp,wr,wpr,wpi,wi,theta;
	double tempr,tempi;

	n=nn << 1;
	j=1;
	for (i=1;i<n;i+=2) {
		if (j > i) {
			swap(data,j,i);
			swap(data,j+1,i+1);
		}
		m=nn;
		while (m >= 2 && j > m) {
			j -= m;
			m >>= 1;
		}
		j += m;
	}
	mmax=2;
	while (n > mmax) {
		istep=mmax << 1;
		theta=isign*(6.28318530717959/mmax);
		wtemp=sin(0.5*theta);
		wpr = -2.0*wtemp*wtemp;
		wpi=sin(theta);
		wr=1.0;
		wi=0.0;
		for (m=1;m<mmax;m+=2) {
			for (i=m;i<=n;i+=istep) {
				j=i+mmax;
				tempr=wr*data[j]-wi*data[j+1];
				tempi=wr*data[j+1]+wi*data[j];
				data[j]=data[i]-tempr;
				data[j+1]=data[i+1]-tempi;
				data[i] += tempr;
				data[i+1] += tempi;
			}
			wr=(wtemp=wr)*wpr-wi*wpi+wr;
			wi=wi*wpr+wtemp*wpi+wi;
		}
		mmax=istep;
	}
}

__device__ double phase_dif(double a,double b,double c,double d)
{
	double phase;
	double real_xcor,imag_xcor;				/*used in phase difference function*/

	real_xcor = a*c + b*d;
	imag_xcor = -a*d + b*c;

	phase = atan2(imag_xcor,real_xcor);

	return (phase);
}


__device__ void realft(double data[], unsigned long n, int isign)		/*FFT*/
{
	//void four1(double data[], unsigned long nn, int isign);
	unsigned long i,i1,i2,i3,i4,np3;
	double c1=0.5,c2,h1r,h1i,h2r,h2i;
	double wr,wi,wpr,wpi,wtemp,theta;

	theta=3.141592653589793/(double) (n>>1);
	if (isign == 1) {
		c2 = -0.5;
		four1(data,n>>1,1);
	} else {
		c2=0.5;
		theta = -theta;
	}
	wtemp=sin(0.5*theta);
	wpr = -2.0*wtemp*wtemp;
	wpi=sin(theta);
	wr=1.0+wpr;
	wi=wpi;
	np3=n+3;
	for (i=2;i<=(n>>2);i++) {
		i4=1+(i3=np3-(i2=1+(i1=i+i-1)));
		h1r=c1*(data[i1]+data[i3]);
		h1i=c1*(data[i2]-data[i4]);
		h2r = -c2*(data[i2]+data[i4]);
		h2i=c2*(data[i1]-data[i3]);
		data[i1]=h1r+wr*h2r-wi*h2i;
		data[i2]=h1i+wr*h2i+wi*h2r;
		data[i3]=h1r-wr*h2r+wi*h2i;
		data[i4] = -h1i+wr*h2i+wi*h2r;
		wr=(wtemp=wr)*wpr-wi*wpi+wr;
		wi=wi*wpr+wtemp*wpi+wi;
	}
	if (isign == 1) {
		data[1] = (h1r=data[1])+data[2];
		data[2] = h1r-data[2];
	} else {
		data[1]=c1*((h1r=data[1])+data[2]);
		data[2]=c1*(h1r-data[2]);
		four1(data,n>>1,-1);
	}
}





/*Kernel function to process a segment */
__global__ void process_data_segment(double *d_out, short * d_t1, short *d_t2, short *d_t3, int message_id)
{
    double t1[129];
    double t2[129],t3[129],ft1[257],ft2[257],ft3[257];
    double p_dif21[128],p_dif31[128];
    double azimuth,elevation;
    double devpoint21;
    double devpoint31;
    double meanpoint21;
    double meanpoint31;


    //get the index of this thread
    int idx = blockIdx.x*threadsPerBlock+ threadIdx.x + message_id * 65536;
    //calculate the time
    double t_dataThread = INIT_SEGMENT+ idx*SEGMENT_STEP;


    /* Apply a cosine filter on each channel */
    int j;
    int startDataIndex=idx*SEG_DATA_LEN;
    for(j=0;j<SEG_DATA_LEN;j++){
        double cosAngle = 0.50-0.50*cos(twoPI*j/SEG_DATA_LEN);
        t1[j+1] = double(d_t1[startDataIndex+j]) *  cosAngle;
        t2[j+1] = double(d_t2[startDataIndex+j]) *  cosAngle;
        t3[j+1] = double(d_t3[startDataIndex+j]) *  cosAngle;
    }

        unsigned long M = SEG_DATA_LEN;

        realft(t1,M,1);
        realft(t2,M,1);
        realft(t3,M,1);
        //double t1ValAfterFFT=t1[1];

        for(j=0;j<SEG_DATA_LEN;j++){
            ft1[j+1] = t1[j+1];
            ft2[j+1] = t2[j+1];
            ft3[j+1] = t3[j+1];
        }
        for(j=0;j<HALF_SEG_DATA_LEN-1;j++){
            ft1[2*SEG_DATA_LEN-2*j-1] = t1[2*j+3];
            ft1[2*SEG_DATA_LEN-2*j] = -1*t1[2*j+4];
            ft2[2*SEG_DATA_LEN-2*j-1] = t2[2*j+3];
            ft2[2*SEG_DATA_LEN-2*j] = -1*t2[2*j+4];
            ft3[2*SEG_DATA_LEN-2*j-1] = t3[2*j+3];
            ft3[2*SEG_DATA_LEN-2*j] = -1*t3[2*j+4];
        }
        ft1[2] = 0.0;
        ft2[2] = 0.0;
        ft3[2] = 0.0;
        ft1[SEG_DATA_LEN+1] = t1[2];
        ft2[SEG_DATA_LEN+1] = t2[2];
        ft3[SEG_DATA_LEN+1] = t3[2];
        ft1[SEG_DATA_LEN+2] = 0.0;
        ft2[SEG_DATA_LEN+2] = 0.0;
        ft3[SEG_DATA_LEN+2] = 0.0;

        for(j=0;j<SEG_DATA_LEN;j++){
            p_dif21[j] = -phase_dif(ft2[2*j+1],ft2[2*(j+1)],ft1[2*j+1],ft1[2*(j+1)]); //Reversing the sign of phase difference
            p_dif31[j] = -phase_dif(ft3[2*j+1],ft3[2*(j+1)],ft1[2*j+1],ft1[2*(j+1)]); //Reversing the sign of phase difference
        }


        // Calculation of slope 1-2
        double gradlimit12=2*Space12*pi/2.99792458/64;
        double grad,current,minimum,phasetmp,phasetmp21[128],phasetmp31[128],grad12,grad13;
        int dd = 0;
        int w;
        grad12=0;
        minimum=1e15;
        for (grad=-1*gradlimit12;grad<gradlimit12;grad=grad+gradlimit12/100){
            current=0;
            for (j=LowerCutOff;j<UpperCutOff;j++){
                phasetmp=p_dif21[j];
                w=0;
                while(w==0){
                    if(phasetmp-grad*j>pi){
                        phasetmp=phasetmp-twoPI;
                    }
                    else if(phasetmp-grad*j<pi*(-1)){
                        phasetmp=phasetmp+twoPI;
                    }
                    else w=1;
                }
                current=current+(phasetmp-grad*j)*(phasetmp-grad*j);
            }
            if (current<minimum){
                minimum=current;
                grad12=grad;
            }
        }

        for (j=LowerCutOff;j<UpperCutOff;j++){
            phasetmp=p_dif21[j];
            w=0;
            while(w==0){
                if((phasetmp-grad12*j)>pi){
                    phasetmp=phasetmp-twoPI;
                }
                else if((phasetmp-grad12*j)<(pi*(-1))){
                    phasetmp=phasetmp+twoPI;
                }
                else w=1;
            }
            phasetmp21[dd] = phasetmp/(j);

            dd += 1;
        }

        devpoint21 = s_deviation(0,UpperCutOff-LowerCutOff,phasetmp21);
        meanpoint21 = mean(0,UpperCutOff-LowerCutOff,phasetmp21);


        // Calculation of slope 1-3
        double gradlimit13=2*Space13*pi/2.99792458/64;

        grad13=0;
        minimum=1e15;
        for (grad=-1*gradlimit13;grad<gradlimit13;grad=grad+gradlimit13/100){
            current=0;
            for (j=LowerCutOff;j<UpperCutOff;j++){
                phasetmp=p_dif31[j];
                w=0;
                while(w==0){
                    if(phasetmp-grad*j>pi){
                        phasetmp=phasetmp-twoPI;
                    }
                    else if(phasetmp-grad*j<pi*(-1)){
                        phasetmp=phasetmp+twoPI;
                    }
                    else w=1;
                }
                current=current+(phasetmp-grad*j)*(phasetmp-grad*j);
            }
            if (current<minimum){
                minimum=current;
                grad13=grad;
            }
        }

        dd = 0;
        for (j=LowerCutOff;j<UpperCutOff;j++){
            phasetmp=p_dif31[j];
            w=0;
            while(w==0){
                if(phasetmp-grad13*j>pi){
                    phasetmp=phasetmp-twoPI;
                }
                else if(phasetmp-grad13*j<pi*(-1)){
                    phasetmp=phasetmp+twoPI;
                }
                else w=1;
            }
            phasetmp31[dd] = phasetmp/(j);

            dd += 1;
        }

        devpoint31 = s_deviation(0,UpperCutOff-LowerCutOff,phasetmp31);
        meanpoint31 = mean(0,UpperCutOff-LowerCutOff,phasetmp31);


        // Calculation of Azimuth and Elevation
        double ele;
        double meanDivGrad12=meanpoint21/gradlimit12;
        double acosMeanDivGrad12=acos(meanDivGrad12);
        azimuth=atan(((meanpoint31/gradlimit13)/((meanDivGrad12)*cos(fifDivPI)))+ tan(fifDivPI));
        if (acosMeanDivGrad12 >= half_pi && acosMeanDivGrad12 <= pi) azimuth = azimuth + pi;
        ele= (meanDivGrad12)/cos(azimuth);
        if((0<ele) && (ele<1)){
            elevation=acos(ele);
            elevation=elevation*divPI;

            azimuth = azimuth + az_shift*twoPI/360.;
            if(azimuth > pi) azimuth = azimuth - twoPI;
            if(azimuth < -pi) azimuth = azimuth + twoPI;
            azimuth=azimuth*divPI;
        }
        else{
            elevation=-1;
        }


        //prepare the output for this entry
        int startIdx=idx*6;
        d_out[startIdx]= t_dataThread*1000;
        d_out[startIdx+1]= azimuth;
        d_out[startIdx+2]= elevation;
        d_out[startIdx+3]= devpoint21;
        d_out[startIdx+4]= devpoint31;
        d_out[startIdx+5]= idx;
}



__global__ void square (float * d_out , float * d_in){
	int index = threadIdx.x;
	float f = d_in[index];
	d_out[index] = f * f;

}


//entry function

void entry(short * input, double * result , int * number_results , int message_id , int input_size){

    //freopen("/home/ec2-user/log_file.txt","w",stdout);
    //cudaThreadExit();
    cudaSetDevice(0);
    
    cudaStream_t stream1;
    cudaError_t stream_error;
    stream_error = cudaStreamCreate(&stream1);
    
    
    
    

    
    


    printf("*** %d %d %d \n",* number_results , message_id , input_size);
    cudaEvent_t start, stop;
    cudaEventCreate(&start);
    cudaEventCreate(&stop);


    long dataNumber = input_size/4;
    long sh_dataBytes = dataNumber*sizeof(short);
    long segmentsNumber = dataNumber/SEG_DATA_LEN;


    int j=0;
    short *h_t1=(short *)malloc(sh_dataBytes);
    short *h_t2=(short *)malloc(sh_dataBytes);
    short *h_t3=(short *)malloc(sh_dataBytes);
    double *h_out=(double *)malloc(sizeof(double)*segmentsNumber*6);


    for(j=0;j<dataNumber;j++){
        h_t1[j] = input[4*j];
        h_t2[j] = input[4*j+1];
        h_t3[j] = input[4*j+2];
    }

    printf("before declaring the gpu pointers\n");
    // declare GPU memory pointers
    short *d_t1;
    short *d_t2;
    short *d_t3;
    double *d_out;

    // allocate GPU memory
    cudaError_t error=cudaMalloc((void**) &d_t1, sh_dataBytes); if (error != cudaSuccess) printf("cuda malloc failed, %s\n",cudaGetErrorString(error));
    error=cudaMalloc((void**) &d_t2, sh_dataBytes); if (error != cudaSuccess) printf("cuda malloc failed, %s\n",cudaGetErrorString(error));
    error=cudaMalloc((void**) &d_t3, sh_dataBytes); if (error != cudaSuccess) printf("cuda malloc failed, %s\n",cudaGetErrorString(error));
    error=cudaMalloc((void**) &d_out, sizeof(double)*segmentsNumber*6);

    // transfer the array to the GPU
    error=cudaMemcpyAsync(d_t1, h_t1, sh_dataBytes, cudaMemcpyHostToDevice, stream1); if (error != cudaSuccess) printf("cuda memcopy to GPU failed, %s\n",cudaGetErrorString(error));
    error=cudaMemcpyAsync(d_t2, h_t2, sh_dataBytes, cudaMemcpyHostToDevice, stream1); if (error != cudaSuccess) printf("cuda memcopy to GPU failed, %s\n",cudaGetErrorString(error));
    error=cudaMemcpyAsync(d_t3, h_t3, sh_dataBytes, cudaMemcpyHostToDevice, stream1); if (error != cudaSuccess) printf("cuda memcopy to GPU failed, %s\n",cudaGetErrorString(error));


    //start checking time
    cudaEventRecord(start);

    // launch the kernel
    // examples used before to call the kernel function:  <<<400000, threadsPerBlock>>> , <<<625, threadsPerBlock>>>
    process_data_segment<<<numBlocks, threadsPerBlock, 0, stream1>>>(d_out, d_t1, d_t2, d_t3, message_id); //for small chucks

    error=cudaGetLastError();
    if (error != cudaSuccess) printf("kernel launch failed, %s\n",cudaGetErrorString(error));

     
    cudaEventRecord(stop);

    cudaEventSynchronize(stop);
    float milliseconds = 0;
    cudaEventElapsedTime(&milliseconds, start, stop);
    printf ("Time taken by the kernel: %f milliseconds\n", milliseconds);

    error=cudaGetLastError();
    if (error != cudaSuccess) printf("kernel execution failed: %d, %s\n",error, cudaGetErrorString(error));


    // copy back the result array to the CPU
    error=cudaMemcpyAsync(h_out, d_out, segmentsNumber*6*sizeof(double), cudaMemcpyDeviceToHost, stream1);
    if (error!= cudaSuccess) printf("copy memory from GPU to host failed, %s\n",cudaGetErrorString(error));




    int result_index = 0 ;
    for(j=0;j<segmentsNumber;j++){
        
        int indexOut=j*6;
        

        if(h_out[indexOut+2]>=0&&h_out[indexOut+3]<DEV_THRESHOLD&&h_out[indexOut+4]<DEV_THRESHOLD)
        {
           
            result[result_index * 6 ] = h_out[indexOut];
            result[result_index * 6 +1] = h_out[indexOut+1];
            result[result_index * 6 +2] = h_out[indexOut+2];
            result[result_index * 6 +3] = h_out[indexOut+3];
            result[result_index * 6 +4] = h_out[indexOut+4];
            result[result_index * 6 +5] = h_out[indexOut+5];

            result_index ++ ;
            (*number_results) ++ ;

        }
    }

    printf("here after copying all results\n");
    printf("the number of results is : %d\n", *number_results);

    cudaFree(d_t1);
    cudaFree(d_t2);
    cudaFree(d_t3);
    cudaFree(d_out);

    free(h_t1);
    free(h_t2);
    free(h_t3);
    free(h_out);
    
    
    printf("say goodbyte");
}










